# C++的几个问题

## 为什么下标重载要写两个

为了让const类型的变量也能调用

## 返回值问题

返回类型如果是引用类型，那么返回局部变量会出现问题。因为局部变量在栈上。函数调用结束后它就会出栈，如果此时返回引用或指向它的指针就会出现错误。

解决办法：定义一个属于函数的静态变量用于存放返回

## 拷贝构造函数

参数必须是const&A，为什么是引用？值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参

默认拷贝构造函数是浅拷贝，也就是说不会为被赋值的新变量分配新的内存，而是将原本的内存直接给新变量。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

调用拷贝构造函数主要有以下场景：**（在重载了移动构造、拷贝构造的情况下）**

- 对象作为函数的参数，以值传递的方式传给函数。　
- 使用一个对象给另一个对象**初始化**

对象作为函数的返回值，以值的方式从函数返回，此时调用的是移动构造函数

如果没有重载移动构造函数那么只会调用拷贝构造函数

对于包含成员对象的类：

1. 默认拷贝构造函数:逐个调用**成员对象**的**拷贝构造函数**
2. 自定义拷贝构造函数:调用成员对象的**默认构造函数**：程序员如果接管这件事情，则编译器不再负责任何默认参数。

## 有关拷贝构造、移动构造、赋值运算符

区别拷贝构造和赋值构造在于是否用于对象初始化

例如class A有构造函数A()和A(int).A a(1)生成的是一个对象，A（1）生成的是一个临时对象，也就是一个右值引用，如果这时将该引用赋值给一个对象就会调用移动构造函数

std::move(a)可将左值a转化为右值

https://www.jianshu.com/p/f5d48a7f5a52

## 虚函数调用问题

简单来说，子类会继承父类的虚函数表同时将在子类中实现的虚函数覆盖原本父类的函数。

基类型指针如果被赋郁子类型地址，那么调用函数随子类型，被赋予基类型地址那么调用函数随基类型（也就是取决于动态绑定的虚函数表，注意虚函数表与类绑定）

## 为什么需要虚析构函数

当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。

调用派生类析构函数 -> 调用成员对象的析构函数 -> 基类的析构函数

## 表达式副作用

一个表达式在求值过程中，对使用的变量不但引用，对它们的值还加以改变，这样的表达式称为有副作用的表达式

## 对于数组不要使用多态

![image-20220621175914042](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220621175914042.png)

这里的问题是BST和BalanceBST大小可能不同，编译器在偏移数组时是按照BST大小偏移的

所以数组的类型必须与函数声明时一致

## 有关函数参数问题

如果函数是值传递，会发生拷贝构造生成一个新的局部变量（与原本不同地址），函数结束时局部变量会被调用析构函数消亡

## 为什么流操作符要被重载为全局？

1）不能在ostream类中对"<<"重载，因为ostream类已经被封装好了。

2）不能在Complex类中对"<<"重载，否则*this对象会混淆。 

```
class Complex
{
    public:
        int a,b;
};

ostream &operator<<(ostream &os, Complex &x){  //cout<<x<<endl;
    os<<x.a<<"+i"<<x.b;   
    // the "os<<x.a" is os.operator<<(x.a);
    // and in the definition of os.operator<<(), it should returned *this
    // which represents a ostream object, but in conflict with the class Complex
    return os;
}     
```