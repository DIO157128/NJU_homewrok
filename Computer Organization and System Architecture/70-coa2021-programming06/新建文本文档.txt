1、将负数取反
2、判断有效位数
3、在有效位数之内进行加法
此时如果有进位，有效位数+1，res中多一个0001
4、对10-19的进行修正，同样考虑进位
5、根据两opr的符号判断是否需要结果符号判断

Test2:
expected:<11001000011101100000000000000000>
src:11001001001110000000000000000000
dest:11001001001110000000000000000000
Test5
expected:11000000100110011001100110010111
src:1100000100000000000000000000...
dest:1100000100000000000000000000...
sub:
2:
expected:11010000000000000000000110000100 but was:<...01000000000000000000[100111]0100>
src:11000000000000000000001100001001
dest:11000000000000000000000100100101
3:
expected:<110[00000000000000000000000000000]> but was:<110[10000000000000000000000001001]>
src:11000000000000000000000000000000
相等的特判
5;
expected:<110[00000000000000000000000000000]> but was:<110[10000100110011001100110011001]>
src:11011000100110011001100110010011
dest:11000001000000000000000000000000



110[000001001100110011001100101]11

110[110001001100110011001100100]11
110[110001001100110011001100100]11

expected:11010000000000000011011000000000 
but was:11010000000000000011010110100000 
src:11000000000000000100010000010001 
dest:11000000000000000000100000010001

expected:11010000000101100000000000000000 
but was:  11010000000101011010000000000000 
src:          11000000000110000110000001010011 
dest:        11010000001101000110000001010011
